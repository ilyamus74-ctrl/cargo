# Пример структурированного `core_api.php`

Небольшой пример показывает, как разбить единственный `core_api.php` на зоны ответственности и централизованный bootstrap.

## Структура
```
examples/structured_core_api/
├── core_api.php          # Точка входа, минимум логики
├── includes/
│   └── bootstrap.php     # Общие зависимости и простой роутер
└── api/
    ├── users.php         # Модуль пользователей
    ├── orders.php        # Модуль заказов
    └── utils.php         # Общие функции
```

## Ключевые идеи
- В точке входа (`core_api.php`) только bootstrap и маршрутизация.
- В `includes/bootstrap.php` — единое место подключения общих зависимостей и простой роутер.
- Каждый модуль (`api/users.php`, `api/orders.php`) содержит собственную бизнес-логику и использует общие утилиты из `api/utils.php`.
- Ответы могут быть не только в JSON: например, `users` возвращает JSON, а `orders` — HTML.
- При росте проекта роутер можно заменить на полноценный контроллер/фреймворк или автозагрузку PSR-4.

## Быстрый прогон
```sh
php -S localhost:8000 -t examples/structured_core_api
# Открыть в браузере или curl:
#   http://localhost:8000/core_api.php?module=users
#   http://localhost:8000/core_api.php?module=orders
```

## Как переписать уже имеющийся `core_api.php` (коротко, без кода)
1. Оставьте в корне только загрузку настроек, подключение bootstrap и вызов роутера.
2. Вынесите общий код (конфиги, подключение к БД, вспомогательные функции) в `includes/bootstrap.php` и `api/utils.php`.
3. Разложите бизнес-логику по модулям в `api/` так, чтобы в каждом файле была своя зона ответственности.
4. В роутере направляйте запрос в нужный модуль по параметру (например, `module=users`), а сам модуль пусть формирует ответ (JSON или HTML).
5. По мере роста замените простые include на автозагрузку (Composer/PSR-4), чтобы модули подключались автоматически.

## А если вопрос про фронтенд `core_api.js`?
Чтобы подхватить новую серверную структуру, обычно достаточно лёгкой чистки JavaScript без полной переписки:
- **Соберите сетевые вызовы в один слой.** Вынесите fetch/FormData-хелперы в отдельный модуль (например, `apiClient.js`), чтобы остальные функции вызывали их, не дублируя код обработки ошибок.
- **Унифицируйте обработку ответов.** Сделайте один «parse + проверка статуса» хелпер и используйте его вместо разбросанных `response.json()`/`response.text()` блоков, как в текущем `core_api.js`.
- **Разделите UI-обновления по зонам.** Функции вроде `reloadUserList`/`reloadDevices` держите в отдельных файлах по разделам приложения, чтобы проще было поддерживать шаблоны (`loadIntoMain`, `showInModal` и т. п.).
- **Сигналы/события вместо прямых вызовов.** Там, где возможно, подключайте переотрисовку через события (например, `document.dispatchEvent(new CustomEvent('users:reload'))`), чтобы код модалок и списков меньше знал друг о друге.
- **Минимальные правки под новый роутинг.** После серверного рефакторинга чаще всего нужно только обновить значения `action`/`module` в FormData и единообразно проверять `status`, без массовых изменений UI-логики.
