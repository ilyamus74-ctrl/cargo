Отличная постановка — вы уже правильно мыслите в сторону универсального слоя коннекторов, а не “под каждый сайт отдельный костыль”.

Судя по текущему UI, у вас уже есть хорошая база: список коннекторов со статусами/ошибками и последним обменом, плюс модалка с параметрами авторизации, сценарием и ручным подтверждением токена/браузера. Это идеально подходит для следующего шага — вынести интеграции в единый протокол.
Как лучше спроектировать коммуникацию (концепт)
1) Слой “Канонической модели данных” (самое важное)

Не хранить “как пришло от сайта” как основной формат.
Сделать 3 канонические сущности:

    ShipmentStatusReport (ваш пункт 1)

    OutboundSubmission (ваш пункт 2)

    TrackAndLabelInfo (ваш пункт 3)

То есть каждый коннектор (CSV/API/HTML) делает:

    extract (получить сырье),

    normalize (преобразовать в канон),

    validate (обязательные поля/типы),

    upsert в ваши таблицы.

Это сразу решает проблему, что у каждого форварда разный формат.
2) Коннектор = адаптер + capability profile

Для каждого сайта хранить в конфиге/БД “профиль возможностей”:

    поддерживает ли:

        report_pull (CSV/HTML/API),

        data_push (форма/AJAX/API),

        track_lookup,

        label_fetch (PDF/ZPL/PNG).

    версия схемы маппинга.

    стратегия авторизации (token/session/manual captcha).

У вас уже есть поля для auth/scenario/manual confirm — это можно расширить до capability-driven поведения без ломки UI.
3) По вашим 3 инструментам — практичная стратегия
Инструмент 1: Отчет данных (CSV/HTML таблицы)

Сделать пайплайн источников:

    csv_parser (с версионируемыми маппингами колонок),

    html_table_parser (с шаблонами селекторов + fallback по заголовкам),

    api_parser (JSON/XML).

Ключевая идея:
Для каждого коннектора хранить “полную сырую таблицу + normalized rows”.

    Raw нужен для аудита/разборов.

    Normalized нужен для логики продукта и отчетов.

Вы правильно предложили “строить полную таблицу каждого сайта” — это сильно ускорит сверки.
Инструмент 2: Подача данных в сторонний сайт (сложный)

Здесь нужен двухрежимный движок:

    API-first (если есть хоть скрытый endpoint).

    Browser automation fallback (Playwright/Puppeteer), когда чисто UI+AJAX+jQuery.

Важно:

    Уметь писать “действия” как декларативные steps (fill/click/wait/intercept/assert), а не код вшивать.

    Ловить сетевые XHR/Fetch и проверять фактический backend response, а не только “кнопка стала зеленой”.

    Делать idempotency key (чтобы повторная отправка не создавала дубль).

У вас уже есть поле scenario_json — логично развить его до mini-DSL для шагов входа/отправки/проверки.
Инструмент 3: Tracking + labels

Разделить на два независимых endpoint-потока:

    track_lookup(tracking_number) → события/статус/ETA,

    label_fetch(shipment_id|tracking_number) → бинарный артефакт + метаданные.

Даже если пересекается с отчетом (п.1), не смешивать в одну задачу: разная частота вызовов, SLA и ретраи.
4) Оркестрация и надежность (чтобы “прод” не болел)

Рекомендую очередь задач (job queue) с типами:

    sync_report,

    submit_shipment,

    track_update,

    fetch_label.

Для каждой:

    retry policy (exp backoff),

    circuit breaker per connector,

    дедупликация задач,

    детальный лог попыток (request/response snapshot, sanitized).

В UI уже есть “последний обмен / ошибка” — это стоит связать с run history по джобам.
5) Безопасность и доступы

    Секреты (пароли/токены) шифровать на уровне хранилища.

    Маскировать в логах.

    Для ручного подтверждения (капча/2FA) — короткоживущие сессии и явный audit trail “кто подтвердил”.

    SSL ignore (у вас уже есть флаг) — только для тестовых сред и под явный контроль.

6) Что бы я предложил как “MVP roadmap”

    Каноническая схема + справочник статусов.

    Коннекторный capability profile.

    Report pipeline (CSV + HTML table) как первый боевой блок.

    Submission engine (API-first + browser fallback).

    Track/Label как отдельные задачи.

    Наблюдаемость: метрики и журнал запусков.

---

## Привязка к операциям в модалке (чтобы UI и архитектура совпадали)

Да, твоя находка отлично ложится на текущую модель операций. Рекомендуемое соответствие:

1. **Операция #1 → ShipmentStatusReport**
   - Получение отчета (XLSX/CSV/API/HTML), нормализация в канонический статусный срез.
2. **Операция #2 → OutboundSubmission**
   - Отправка/подача данных во внешний сервис (API-first, browser fallback).
3. **Операция #3 → TrackAndLabelInfo**
   - Получение трекинга и label/документов как отдельный поток.

Почему это хорошо:

- Понятная декомпозиция в UI: каждая вкладка = отдельный сценарий.
- Проще запускать и мониторить по cron: разные частоты/ретраи для разных задач.
- Проще дебажить: падение привязывается к конкретной операции.

Практически: можно оставить человеко-понятные названия вкладок (`Операция #1/#2/#3`) и рядом фиксировать тех.тип операции (`ShipmentStatusReport`, `OutboundSubmission`, `TrackAndLabelInfo`) в конфиге.
