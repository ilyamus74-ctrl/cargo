# Гибридный режим: перенос JS-flow в native (инструкция/чеклист)

Цель: сохранить веб‑UI (кнопки/формы/модалки) без изменений, но перенести логику скан‑flow из JS в приложение, чтобы APP читало `device-scan-config` и исполняло его своим движком. В браузере без APP всё продолжает работать как раньше через JS.

> Ключевая идея: **UI остаётся в вебе, flow исполняется в APP**. Веб‑страница остаётся источником сценариев (`device-scan-config`), а приложение — исполнителем.

## 0) Термины
- **JS‑flow**: текущая схема, где `device-scan-config` читает JS и управляет DOM.
- **Native‑flow**: схема, где `device-scan-config` читает приложение и выполняет стандартные операции (fill field, open scanner, set step и т.д.).
- **Гибрид**: веб‑кнопки остаются, flow уходит в APP.

## 1) Подготовка (аудит текущей схемы)
- [ ] Зафиксировать, какие страницы используют `device-scan-config`.
- [ ] Зафиксировать, какие JS‑функции “дергаются” из flow (пример: `setCellFromQR`, `clearToolsStorageMoveSearch`, `triggerSaveButton`, `confirmBatchMove`).
- [ ] Зафиксировать, какие DOM‑элементы критичны для flow (ids/селекторы полей, кнопок, модалок, вкладок).

## 2) Определить стандартные операции “движка” (минимальный набор)
Пример базового набора операций, которые должен поддерживать APP‑движок:
- [ ] `open_scanner(mode)` — открыть сканер в нужном режиме.
- [ ] `fill_field(field_id, value)` — выставить значение и триггернуть события ввода.
- [ ] `set_step(step_id)` — сменить активный шаг сценария.
- [ ] `web(name)` / `web_callback(name, payload)` — вызов стандартных действий (см. ниже список маппинга).
- [ ] `noop` — ничего не делать.

## 3) Маппинг “web‑действий” на нативные операции
Цель: заменить JS‑функции, вызываемые из flow, на **стандартные команды приложения**.

- [ ] Составить таблицу соответствия:
  - `setCellFromQR` → `set_select_value #cellId` (+ события)
  - `clearToolsStorageMoveSearch` → `set_input_value #tools-storage-move-search = ''` (+ события)
  - `triggerSaveButton` → `click button[data-core-action="warehouse_move_save_cell"]`
  - `confirmBatchMove` → проверить `#warehouse-move-batch-cell`, затем `click button[data-core-action="warehouse_move_batch_assign"]`

> Эта таблица — ключ: **APP выполняет DOM‑команды через WebView**, а не вызывает JS‑функции страницы.

## 4) Движок в APP (чтение `device-scan-config`)
- [ ] Извлечь JSON из `#device-scan-config` в DOM.
- [ ] Реализовать парсер + state machine:
  - [ ] `task_id`
  - [ ] `contexts` + `active_context`
  - [ ] `flow` (start/steps/on_action/next_on_scan)
  - [ ] `buttons` (какая кнопка = какая команда)
- [ ] Реализовать обработку скан‑результатов:
  - [ ] опция `qr/barcode/ocr` → `fill_field` или `web_callback`
  - [ ] смена шагов (set_step)
- [ ] Реализовать вызовы стандартных операций (см. пункт 2).

## 5) Разделение Web / APP поведения (гибрид)
- [ ] В приложении включать **native‑flow**, в браузере оставить **JS‑flow**.
- [ ] В вебе оставить `device-scan-config` как источник сценариев (без изменений).
- [ ] При необходимости добавить флаг окружения (например, `window.isNativeApp`) и использовать его только для диагностики.

## 6) Частичный рефакторинг (пошагово)
Делать по одному модулю, после каждого — проверка.

### Этап 1: Warehouse Move
- [ ] Перевести flow на native‑движок для `warehouse_move`.
- [ ] Оставить JS‑код как fallback (для веб‑браузеров).
- [ ] Проверить: скан → поиск → открытие модалки → установка ячейки → сохранение.

### Этап 2: Tools Management
- [ ] Перевести flow на native‑движок для `tools_management`.
- [ ] Проверить: скан → фильтр → модалки (user/cell) → сохранение.

### Этап 3: Warehouse Item In
- [ ] Перевести flow на native‑движок для `warehouse_item_in` batch‑modal.
- [ ] Проверить: barcode → ocr → measure → submit.

## 7) Контрольный список после каждого этапа (обязательная проверка)
> Это обязательная “проверка успешности” после частичного рефакторинга.

- [ ] **В APP**: скан работает, шаги flow выполняются корректно.
- [ ] **В APP**: кнопки веб‑страницы кликаются и работают как раньше.
- [ ] **В браузере без APP**: JS‑flow продолжает работать без изменений.
- [ ] Нет регрессий в модалках (открытие/закрытие, выбор значений, сохранение).
- [ ] Нет дубля выполнения (например, и JS, и APP одновременно).

## 8) Финальная стабилизация
- [ ] Удалить лишние JS‑хуки, которые дублируют native‑flow (если принято решение убирать).
- [ ] Обновить документацию по эксплуатации (что где работает: web vs app).
- [ ] Проверить логику `CoreAPI` — она остаётся основным AJAX‑клиентом.

---

## Зафиксировал результаты
- Пункты 0–1: `DOCS/native_flow_refactor_checklist_p0_p1.md`.
- Пункты 2–3: `DOCS/native_flow_refactor_checklist_p2_p3.md`.
- Пункт 4: `DOCS/native_flow_refactor_checklist_p4.md`.
- Пункт 5: `DOCS/native_flow_refactor_checklist_p5.md`.
- Пункт 6: `DOCS/native_flow_refactor_checklist_p6.md`.
- Пункт 7: `DOCS/native_flow_refactor_checklist_p7.md`.
- Пункт 8: `DOCS/native_flow_refactor_checklist_p8.md`.
---

## Результат
После выполнения чеклиста:
- APP использует `device-scan-config` как сценарий и исполняет его нативно.
- Веб‑клиент продолжает работать как раньше.
- Рефакторинг можно делать поэтапно с безопасными проверками после каждого шага.
