#!/usr/bin/env node
'use strict';

const fs = require('fs');
const path = require('path');
const os = require('os');
const puppeteer = require('puppeteer');

function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function applyVars(value, vars) {
  if (typeof value !== 'string') return value;
  return value.replace(/\$\{([a-zA-Z0-9_]+)\}/g, (_, key) => (vars[key] ?? ''));
}

function looksLikeWildcardSelector(sel) {
  return typeof sel === 'string' && sel.includes('*');
}

// делаем XPath по подстрокам (для твоего "*a*b*c*")
function wildcardToXPathContains(sel) {
  const parts = sel.split('*').map(s => s.trim()).filter(Boolean);
  if (!parts.length) return null;

  // ищем по class/id/тексту/атрибутам — максимально терпимо
  // можно сузить до contains(@class, ...)
  const predicates = parts.map(p =>
    `contains(@class, "${p}") or contains(@id, "${p}") or contains(normalize-space(.), "${p}")`
  );
  return `//*[${predicates.join(' or ')}]`;
}

async function waitForSelectorAny(page, selector, timeout = 30000) {
  if (!selector) throw new Error('success.selector is required');

  if (looksLikeWildcardSelector(selector)) {
    const xp = wildcardToXPathContains(selector);
    if (!xp) throw new Error('Invalid wildcard selector');
    await page.waitForXPath(xp, { timeout });
    return { type: 'xpath', value: xp };
  }

  // обычный CSS
  await page.waitForSelector(selector, { timeout });
  return { type: 'css', value: selector };
}

async function fillByNameOrSelector(page, key, value, vars) {
  const v = applyVars(String(value ?? ''), vars);

  // если key похож на CSS — считаем, что это селектор
  const isSelector = key.includes('[') || key.includes('.') || key.includes('#') || key.includes(' ') || key.includes(':');
  const selector = isSelector ? key : `input[name="${key}"]`;

  await page.waitForSelector(selector, { timeout: 30000 });
  await page.click(selector, { clickCount: 3 });
  await page.keyboard.press('Backspace');
  await page.type(selector, v);
}

async function ensureLogin(page, payload, vars) {
  const login = payload.login;
  if (!login?.url || !login?.fields) return;

  // открываем логин страницу
  await page.goto(applyVars(login.url, vars), { waitUntil: 'domcontentloaded' });

  // заполняем поля
  const fields = login.fields || {};
  for (const [k, v] of Object.entries(fields)) {
    await fillByNameOrSelector(page, k, v, vars);
  }

  // сабмит: если задан submit_selector — кликаем, иначе Enter
  const submitSel = login.submit_selector || 'button[type="submit"], input[type="submit"]';
  const hasSubmit = await page.$(submitSel);

  if (hasSubmit) {
    await Promise.all([
      page.waitForNavigation({ waitUntil: 'domcontentloaded' }).catch(() => null),
      page.click(submitSel),
    ]);
  } else {
    await Promise.all([
      page.waitForNavigation({ waitUntil: 'domcontentloaded' }).catch(() => null),
      page.keyboard.press('Enter'),
    ]);
  }

  // проверяем успех
  if (payload.success?.selector) {
    await waitForSelectorAny(page, payload.success.selector, 30000);
  }
}

function resolveExecutableCandidates() {
  const fromEnv = (process.env.PUPPETEER_EXECUTABLE_PATH || '').trim();
  const candidates = [
    fromEnv,
    '/usr/bin/chromium-browser',
    '/usr/bin/chromium',
    '/usr/lib64/chromium-browser/chromium-browser',
    '/usr/lib/chromium/chromium',
    '/usr/bin/google-chrome-stable',
    '/usr/bin/google-chrome',
  ].filter(Boolean);

  const expanded = [];
  for (const candidate of candidates) {
    expanded.push(candidate);
    try {
      const rp = fs.realpathSync(candidate);
      if (rp && rp !== candidate) expanded.push(rp);
    } catch (_) {}
  }

  const existing = [];
  const seen = new Set();
  for (const candidate of expanded) {
    if (seen.has(candidate)) continue;
    seen.add(candidate);
    try {
      if (fs.existsSync(candidate)) existing.push(candidate);
    } catch (_) {}
  }

  return existing;
}

async function launchBrowserWithFallback(puppeteerLib, executableCandidates, sslIgnore, userDataDir, runtimeHomeDir) {
  const baseArgs = [
    '--no-sandbox',
    '--disable-setuid-sandbox',
    '--disable-crash-reporter',
    '--disable-breakpad',
    '--disable-features=Crashpad,CrashReporting',
    '--disable-crashpad-for-testing',
    '--no-first-run',
    '--no-default-browser-check',
    '--disable-dev-shm-usage',
    '--no-zygote',
    `--user-data-dir=${userDataDir}`,
  ];

  const launchEnv = {
    ...process.env,
    HOME: runtimeHomeDir,
    XDG_CONFIG_HOME: path.join(runtimeHomeDir, '.config'),
    XDG_CACHE_HOME: path.join(runtimeHomeDir, '.cache'),
  };

  const strategyTemplates = [
    { name: 'primary', opts: { args: baseArgs, env: launchEnv } },
    { name: 'pipe-mode', opts: { pipe: true, args: baseArgs, env: launchEnv } },
    { name: 'headless-shell', opts: { headless: 'shell', args: baseArgs, env: launchEnv } },
  ];

  const candidates = [undefined, ...executableCandidates];
  const errors = [];
  let lastErr = null;

  for (const candidate of candidates) {
    for (const strategy of strategyTemplates) {
      const strategyName = `${strategy.name}${candidate ? `@${candidate}` : '@default'}`;
      try {
        return await puppeteerLib.launch({
          headless: true,
          ignoreHTTPSErrors: sslIgnore,
          executablePath: candidate,
          ...strategy.opts,
        });
      } catch (err) {
        const message = err?.message ? err.message : String(err);
        errors.push(`${strategyName}: ${message}`);
        lastErr = err;
      }
    }
  }

  const e = new Error('Browser launch failed. Attempts: ' + errors.join(' | '));
  e.cause = lastErr;
  throw e;
}

async function safeRm(dir) {
  if (!dir) return;
  try { fs.rmSync(dir, { recursive: true, force: true }); } catch (_) {}
}

async function waitForDownloadedFile(dir, ext, timeoutMs) {
  const started = Date.now();
  while (Date.now() - started < timeoutMs) {
    const files = fs.readdirSync(dir)
      .filter((name) => !name.endsWith('.crdownload'))
      .filter((name) => name.toLowerCase().endsWith(`.${ext.toLowerCase()}`));

    if (files.length > 0) {
      files.sort((a, b) => fs.statSync(path.join(dir, b)).mtimeMs - fs.statSync(path.join(dir, a)).mtimeMs);
      const fullPath = path.join(dir, files[0]);
      const size = fs.statSync(fullPath).size;
      return { fullPath, size };
    }
    await sleep(500);
  }
  return null;
}


function guessFilenameFromHeaders(headers, fallbackExt) {
  const cd = headers['content-disposition'] || headers['Content-Disposition'];
  if (cd) {
    const m = /filename\*=UTF-8''([^;]+)|filename="([^"]+)"|filename=([^;]+)/i.exec(cd);
    const raw = decodeURIComponent(m?.[1] || m?.[2] || m?.[3] || '').trim();
    if (raw) return raw.replace(/[/\\?%*:|"<>]/g, '_');
  }
  return `report_${Date.now()}.${fallbackExt}`;
}

function isLikelyTargetFile(resp, ext) {
  const url = resp.url().toLowerCase();
  const headers = resp.headers();
  const ct = (headers['content-type'] || '').toLowerCase();
  const cd = (headers['content-disposition'] || '').toLowerCase();

  if (url.endsWith(`.${ext}`)) return true;
  if (cd.includes(`.${ext}`)) return true;

  // типы для excel
  if (ext === 'xlsx' && (
    ct.includes('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet') ||
    ct.includes('application/octet-stream')
  )) return true;

  return false;
}

async function waitAndSaveDownloadViaResponse(page, downloadDir, ext, timeoutMs) {
  return new Promise((resolve, reject) => {
    let done = false;

    const timer = setTimeout(() => {
      cleanup();
      reject(new Error(`Download not found via network (.${ext}) within ${timeoutMs}ms`));
    }, timeoutMs);

    function cleanup() {
      if (done) return;
      done = true;
      clearTimeout(timer);
      page.off('response', onResponse);
    }

    async function onResponse(resp) {
      try {
        if (done) return;
        if (!resp.ok()) return;

        if (!isLikelyTargetFile(resp, ext)) return;

        const headers = resp.headers();
        const filename = guessFilenameFromHeaders(headers, ext);
        const fullPath = path.join(downloadDir, filename);

        const buf = await resp.buffer();
        fs.writeFileSync(fullPath, buf);

        cleanup();
        resolve({ fullPath, size: buf.length });
      } catch (e) {
        cleanup();
        reject(e);
      }
    }

    page.on('response', onResponse);
  });
}

async function configureDownloadBehavior(page, downloadDir) {
  // Ошибка "Requesting main frame too early!" лечится тем, что CDP настраиваем
  // уже после первого page.goto (когда main frame существует).
  const client = await page.target().createCDPSession();


  // пробуем новый, если не прокатит — старый
  try {
    await client.send('Browser.setDownloadBehavior', {
      behavior: 'allow',
      downloadPath: downloadDir,
    });
    return;
  } catch (_) {}

  await client.send('Page.setDownloadBehavior', { behavior: 'allow', downloadPath: downloadDir });
}

/**
 * Простейшее определение "я залогинен или нет"
 * 1) по URL (если улетели на /login)
 * 2) по наличию селекторов формы логина
 * 3) по наличию "признака авторизации" на странице (селектор, который есть только после логина)
 */
async function isLoggedIn(page, cfg) {
  const url = page.url() || '';
  if (cfg.login_url_contains && url.includes(cfg.login_url_contains)) return false;

  if (cfg.login_form_selector) {
    const el = await page.$(cfg.login_form_selector);
    if (el) return false;
  }

  if (cfg.logged_in_selector) {
    try {
      await page.waitForSelector(cfg.logged_in_selector, { timeout: 1500 });
      return true;
    } catch (_) {
      return false;
    }
  }

  // если нет cfg.logged_in_selector — считаем залогинен, когда нет формы логина
  return true;
}

(async () => {
  const args = process.argv.slice(2);
  const payloadRaw = args[0] || '{}';

  let payload;
  try {
    payload = JSON.parse(payloadRaw);
  } catch (_) {
    process.stdout.write(JSON.stringify({ ok: false, message: 'Invalid JSON payload' }) + '\n');
    process.exit(1);
  }

  const vars = payload.vars || {};
  const steps = Array.isArray(payload.steps) ? payload.steps : [];
  const fileExtension = String(payload.file_extension || 'xlsx').toLowerCase();
  const sslIgnore = !!payload.ssl_ignore;

  // login config (опционально)
  const login = payload.login || null;
  // пример ожидаемой структуры в payload:
  // "login": {
  //   "url": "https://dev-backend.colibri.az/login",
  //   "username_selector": "input[name='username']",
  //   "password_selector": "input[name='password']",
  //   "submit_selector": "button[type='submit']",
  //   "username": "user",
  //   "password": "pass",
  //   "logged_in_selector": "a[href*='logout']",
  //   "login_form_selector": "form#loginForm",
  //   "login_url_contains": "/login"
  // }

  if (steps.length === 0) {
    process.stdout.write(JSON.stringify({ ok: false, message: 'No steps provided' }) + '\n');
    process.exit(1);
  }

  const downloadDir = fs.mkdtempSync(path.join(os.tmpdir(), 'connector-op-'));
  let browser;
  let userDataDir = '';
  let runtimeHomeDir = '';

  const executableCandidates = resolveExecutableCandidates();
  const executablePath = executableCandidates[0] || null;

  try {
    userDataDir = fs.mkdtempSync(path.join(os.tmpdir(), 'connector-browser-profile-'));
    runtimeHomeDir = fs.mkdtempSync(path.join(os.tmpdir(), 'connector-browser-home-'));
    fs.mkdirSync(path.join(runtimeHomeDir, '.config'), { recursive: true });
    fs.mkdirSync(path.join(runtimeHomeDir, '.cache'), { recursive: true });

browser = await launchBrowserWithFallback(puppeteer, executableCandidates, sslIgnore, userDataDir, runtimeHomeDir);

const page = await browser.newPage();
page.setDefaultTimeout(30000);
page.setDefaultNavigationTimeout(60000);

// гарантируем main frame
await page.goto('about:blank', { waitUntil: 'domcontentloaded' });

// headers (ОДИН РАЗ)
const extraHeaders = {};
if (payload.cookies && typeof payload.cookies === 'string' && payload.cookies.trim() !== '') {
  extraHeaders.Cookie = payload.cookies.trim();
}
if (payload.auth_token && typeof payload.auth_token === 'string' && payload.auth_token.trim() !== '') {
  extraHeaders.Authorization = `Bearer ${payload.auth_token.trim()}`;
}
if (Object.keys(extraHeaders).length) {
  await page.setExtraHTTPHeaders(extraHeaders);
}

// downloads CDP (ОДИН РАЗ)
//await configureDownloadBehavior(page, downloadDir);

// login (ОДИН РАЗ)
await ensureLogin(page, payload, vars);

// helpers (ОДИН РАЗ)
async function doClick(selector, step) {
  await page.waitForSelector(selector, { visible: !!step?.visible });
  if (step?.wait_navigation) {
    await Promise.all([
      page.waitForNavigation({ waitUntil: step.wait_until || 'domcontentloaded' }),
      page.click(selector),
    ]);
  } else {
    await page.click(selector);
  }
}

async function doFill(selector, text, step) {
  await page.waitForSelector(selector, { visible: !!step?.visible });
  await page.focus(selector);
  if (step?.clear !== false) {
    await page.click(selector, { clickCount: 3 });
    await page.keyboard.press('Backspace');
  }
  await page.type(selector, text, { delay: Number(step?.delay_ms || 0) });
}

    // headers

    for (const step of steps) {
      const action = String(step.action || '').trim();
      if (!action) continue;

      if (action === 'goto') {
        const url = applyVars(step.url || '', vars);
        if (!url) throw new Error('goto.url is required');

        await page.goto(url, { waitUntil: step.wait_until || 'domcontentloaded' });


        continue;
      }

      if (action === 'click') {
        const selector = applyVars(step.selector || '', vars);
        if (!selector) throw new Error('click.selector is required');
        await doClick(selector, step);
        continue;
      }

      if (action === 'fill' || action === 'type') {
        const selector = applyVars(step.selector || '', vars);
        if (!selector) throw new Error(`${action}.selector is required`);

        let text = '';
        if (typeof step.text === 'string') text = step.text;
        else if (typeof step.value === 'string') text = step.value;
        else if (typeof step.var === 'string') text = String(vars[step.var] ?? '');
        text = applyVars(text, vars);

        await doFill(selector, text, step);
        continue;
      }

      if (action === 'wait_for') {
        const selector = applyVars(step.selector || '', vars);
        const timeout = Number(step.timeout_ms || 10000);
        if (selector) await page.waitForSelector(selector, { timeout, visible: !!step.visible });
        else await page.waitForTimeout(timeout);
        continue;
      }

      if (action === 'download') {
        // иногда после submit скачивание стартует не мгновенно — подождём чуть
        const timeoutMs = Number(step.timeout_ms || 60000);
        const downloaded = await waitForDownloadedFile(downloadDir, fileExtension, timeoutMs);
        if (!downloaded) throw new Error(`Download not found with .${fileExtension} within ${timeoutMs}ms`);

        process.stdout.write(JSON.stringify({
          ok: true,
          message: 'Файл успешно скачан через browser steps',
          file_path: downloaded.fullPath,
          file_size: downloaded.size,
          file_extension: fileExtension,
          executable_path: executablePath,
          download_dir: downloadDir,
        }) + '\n');

        await browser.close();
        await safeRm(userDataDir);
        await safeRm(runtimeHomeDir);
        process.exit(0);
      }

      throw new Error(`Unsupported action: ${action}`);
    }

    throw new Error('Download step missing');
  } catch (err) {
    if (browser) { try { await browser.close(); } catch (_) {} }
    await safeRm(userDataDir);
    await safeRm(runtimeHomeDir);

    process.stdout.write(JSON.stringify({
      ok: false,
      message: err?.message || 'Browser test failed',
      executable_path: executablePath,
    }) + '\n');
    process.exit(1);
  }
})();